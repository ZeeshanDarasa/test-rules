name: Semgrep Security Scan

on:
  pull_request:
  pull_request_target:
  merge_group:
  push:
    branches: [ main, develop ]
  # Triggered by repository rulesets
  repository_dispatch:
    types: [security-scan, semgrep-scan]

jobs:
  semgrep:
    name: Semgrep Scan
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check for scannable code
        id: check-code
        run: |
          echo "=== DEBUG: Current directory structure ==="
          find . -type f -name "*.py" -o -name "*.txt" -o -name "*.ini" | head -20
          echo ""
          
          echo "=== DEBUG: All files in vulncode directory ==="
          if [ -d "vulncode" ]; then
            find vulncode -type f | head -20
          else
            echo "vulncode directory not found"
          fi
          echo ""
          
          # Check if there are any source code files to scan (including subdirectories)
          SOURCE_FILES=$(find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.java" -o -name "*.go" -o -name "*.rs" -o -name "*.rb" -o -name "*.php" -o -name "*.cs" -o -name "*.cpp" -o -name "*.c" -o -name "*.h" -o -name "*.hpp" -o -name "*.swift" -o -name "*.kt" -o -name "*.scala" -o -name "*.clj" -o -name "*.hs" -o -name "*.ml" -o -name "*.fs" -o -name "*.vb" -o -name "*.sh" -o -name "*.ps1" -o -name "*.bat" -o -name "*.sql" -o -name "*.html" -o -name "*.css" -o -name "*.xml" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" -o -name "*.toml" -o -name "*.ini" -o -name "*.cfg" -o -name "*.conf" -o -name "requirements.txt" -o -name "package.json" -o -name "Pipfile" -o -name "Cargo.toml" -o -name "go.mod" -o -name "Gemfile" -o -name "composer.json" \) -not -path "./.git/*" -not -path "./.github/*" -not -path "./node_modules/*" -not -path "./vendor/*" -not -path "./dist/*" -not -path "./build/*" -not -path "./target/*" 2>/dev/null | head -20)
          
          if [ -z "$SOURCE_FILES" ]; then
            echo "No source code files found to scan"
            echo "has_code=false" >> $GITHUB_OUTPUT
          else
            echo "Found source code files to scan:"
            echo "$SOURCE_FILES"
            echo "has_code=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Run Semgrep
        if: steps.check-code.outputs.has_code == 'true'
        id: semgrep
        run: |
          # Install semgrep
          pip install semgrep
          
          # Debug: Show what files exist
          echo "=== Files in current directory ==="
          find . -type f -name "*.py" -o -name "*.js" -o -name "*.ts" | head -20
          
          echo "=== Contents of vulncode directory ==="
          ls -la vulncode/ || echo "vulncode directory not found"
          
          # Run semgrep with --no-git-ignore to scan all files regardless of git status
          echo "=== Running Semgrep with --no-git-ignore ==="
          semgrep \
            --config=auto \
            --sarif \
            --output=semgrep.sarif \
            --no-git-ignore \
            --verbose \
            --include="*.py" \
            --include="*.js" \
            --include="*.ts" \
            --include="*.java" \
            --include="*.go" \
            --include="*.rb" \
            --include="*.php" \
            --include="*.cs" \
            --include="*.cpp" \
            --include="*.c" \
            --include="*.h" \
            --exclude=".git/" \
            --error --severity=ERROR --quiet \
            --exclude="node_modules/" \
            --exclude="vendor/" \
            . || true
            
          # Show SARIF file info
          if [ -f semgrep.sarif ]; then
            echo "=== SARIF file created successfully ==="
            echo "Size: $(wc -c < semgrep.sarif) bytes"
            echo "Results count: $(jq '[.runs[].results[]] | length' semgrep.sarif 2>/dev/null || echo 'Could not parse')"
          else
            echo "=== SARIF file not created ==="
          fi
      
      - name: Create empty SARIF if no code to scan
        if: steps.check-code.outputs.has_code == 'false'
        run: |
          cat > semgrep.sarif << 'EOF'
          {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "Semgrep",
                    "version": "latest"
                  }
                },
                "results": [],
                "invocations": [
                  {
                    "executionSuccessful": true,
                    "commandLine": "semgrep scan --no-code-found",
                    "endTimeUtc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                  }
                ]
              }
            ]
          }
          EOF
      
      - name: Upload to DefectDojo
        if: always()
        run: |
          if [ -f semgrep.sarif ]; then
            curl -X POST "${{ secrets.DEFECTDOJO_URL }}/api/v2/import-scan/" \
              -H "Authorization: Token ${{ secrets.DEFECTDOJO_TOKEN }}" \
              -F "scan_type=Semgrep JSON Report" \
              -F "file=@semgrep.sarif" \
              -F "product_name=${{ github.repository }}" \
              -F "engagement_name=Automated Security Scan - $(date +%Y-%m-%d)" \
              -F "test_title=Semgrep SAST Scan - ${{ github.sha }}" \
              -F "active=true" \
              -F "verified=false" \
              -F "close_old_findings=true" \
              -F "push_to_jira=false" \
              -F "minimum_severity=Info" \
              -F "scan_date=$(date +%Y-%m-%d)" \
              -F "tags=semgrep,sast,automated" || echo "Failed to upload to DefectDojo"
          fi
      
      - name: Check for high/critical findings
        if: always()
        run: |
          if [ -f semgrep.sarif ]; then
            # Extract severity levels from SARIF and count high/critical findings
            HIGH_CRITICAL_COUNT=$(jq '[.runs[].results[] | select(.level == "error" or .ruleId | test(".*\\.(high|critical)$"))] | length' semgrep.sarif 2>/dev/null || echo "0")
            
            echo "High/Critical findings count: $HIGH_CRITICAL_COUNT"
            
            if [ "$HIGH_CRITICAL_COUNT" -gt 0 ]; then
              echo "‚ùå Found $HIGH_CRITICAL_COUNT high/critical security findings!"
              echo "Please review and fix the security issues before merging."
              exit 1
            else
              echo "‚úÖ No high/critical security findings detected."
            fi
          else
            echo "‚ö†Ô∏è SARIF file not found, but continuing..."
          fi
      
      - name: Comment PR with results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            if (fs.existsSync('semgrep.sarif')) {
              const sarif = JSON.parse(fs.readFileSync('semgrep.sarif', 'utf8'));
              const results = sarif.runs?.[0]?.results || [];
              const highCritical = results.filter(r => 
                r.level === 'error' || 
                (r.ruleId && r.ruleId.match(/\.(high|critical)$/))
              );
              
              const body = `## üîç Semgrep Security Scan Results
              
              **Total findings:** ${results.length}
              **High/Critical findings:** ${highCritical.length}
              
              ${highCritical.length > 0 ? 
                '‚ùå **Action Required:** Please address high/critical security findings before merging.' : 
                '‚úÖ **No high/critical security issues found.**'
              }
              
              View detailed results in DefectDojo: ${{ secrets.DEFECTDOJO_URL }}`;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }
